package og

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net"
	"net/http"
	"net/url"
	"time"
)

// OG
type (
	GameOG struct {
		//game.Server
		// Token  string `json:"token"`
		Status     string                 `json:"status"`
		Data       map[string]interface{} `json:"data"`
		User       string
		Key        string
		ProviderId int
		GameCode   string
		/*
			Agent  string

			DesKey string
			Md5Key string
		*/
	}
)

const (
	ERR_SYSTEM_ERROR       = "system error"
	ERR_NET_ERROR          = "network error"
	ERR_AUTH_FAILED        = "auth failed"
	ERR_SIGN_ERROR         = "sign error"
	ERR_APPID_ERROR        = "appid error"
	ERR_SECRET_ERROR       = "secret error"
	ERR_LACK_PARAMETERS    = "Lack of necessary parameters"
	ERR_BALANCE_NOT_ENOUGH = "balance is not enough"
	ERR_ILLEGAL_IP         = "illegal ip"
	KC_RAND_KIND_NUM       = 0    // 纯数字
	KC_RAND_KIND_LOWER     = 1    // 小写字母
	KC_RAND_KIND_UPPER     = 2    // 大写字母
	KC_RAND_KIND_ALL       = 3    // 数字、大小写字母
	DEFAULT_PAGE           = "1"  //默认第几页
	DEFAULT_PAGECOUNT      = "10" //默认一页多少数量
	LOGIN_EXPIRED_TIME     = 3600 //token过期时间
	//redis key值
	INFO_USER  = "info_user"
	INFO_MERCH = "info_merch"
	GAME_AG    = "1"
	GAME_BBIN  = "2"
	GAME_SB    = "3"
	GAME_AB    = "4"
)

// 代理本地服务器
func NewHttpClient(proxyAddr string) (*http.Client, error) {
	proxy, err := url.Parse(proxyAddr)
	if err != nil {
		return nil, err
	}
	netTransport := &http.Transport{
		//Proxy: http.ProxyFromEnvironment,
		Proxy: http.ProxyURL(proxy),
		Dial: func(netw, addr string) (net.Conn, error) {
			c, err := net.DialTimeout(netw, addr, time.Second*time.Duration(15))
			if err != nil {
				return nil, err
			}
			return c, nil
		},
		MaxIdleConnsPerHost:   20,                              //每个host最大空闲连接
		ResponseHeaderTimeout: time.Second * time.Duration(20), //数据收发5秒超时
	}

	return &http.Client{
		Timeout:   time.Second * 25,
		Transport: netTransport,
	}, nil
}

//Post 请求方法,返回请求的消息
func HttpPOSTBills(client *http.Client, Url string, params map[string]interface{}) (body []byte, err error) {

	fmt.Println("url:", Url)
	jsonstr, err := json.Marshal(params)
	fmt.Println("req:", string(jsonstr))
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest("POST", Url, bytes.NewBuffer(jsonstr))
	req.Header.Add("Content-Type", "application/json;charset=utf-8")
	req.Header.Add("Content-Type", "multipart/form-data")
	//req.Header.Add("Content-Type", "application/json")

	response, err := client.Do(req)
	if err != nil {
		err = fmt.Errorf("HTTP GET Code=%v, URI=%v, err=%v", response.StatusCode, Url, err)
		return nil, err
	}
	defer response.Body.Close()
	return ioutil.ReadAll(response.Body)
}

// 获取Token
func HttpGET(client *http.Client, url string) (body []byte, err error) {
	resp, err := http.NewRequest("GET", url, nil)
	resp.Header.Add("X-Operator", ALLBET_OPERATOR_NAME)
	resp.Header.Add("X-Key", TEST_OPERATOR_KEY)
	response, err := client.Do(resp)
	if err != nil {
		return nil, err
	}
	if response.StatusCode != http.StatusOK || err != nil {
		err = fmt.Errorf("HTTP GET Code=%v, URI=%v, err=%v", response.StatusCode, url, err)
		return
	}
	defer response.Body.Close()
	return ioutil.ReadAll(response.Body)
}

// 注册
func HttpPOST(client *http.Client, Url string, msg map[string]interface{}) (body []byte, err error) {
	data := make(map[string]interface{})
	for key, value := range msg {
		if key != "X-Token" {
			switch v := value.(type) {
			case string:
				//postValue.Add(key, v)
				data[key] = v
			case float64:
				data[key] = v
			}
		}
	}
	jsonstr, err := json.Marshal(data)
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest("POST", Url, bytes.NewBuffer([]byte(jsonstr)))
	req.Header.Add("X-Token", msg["X-Token"].(string))
	req.Header.Add("Content-Type", "application/json; charset=utf-8")
	response, err := client.Do(req)
	if err != nil {
		err = fmt.Errorf("HTTP GET Code=%v, URI=%v, err=%v", response.StatusCode, Url, err)
		return nil, err
	}
	defer response.Body.Close()
	return ioutil.ReadAll(response.Body)
}

// update balance
func HttpPOSTUpdataBalance(client *http.Client, Url string, msg map[string]interface{}) (body []byte, err error) {
	data := make(map[string]interface{})
	for key, value := range msg {
		if key != "X-Token" {
			switch v := value.(type) {
			case string:
				data[key] = v
			case float64:
				data[key] = v
			}
		}
	}
	jsonstr, err := json.Marshal(data)
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest("POST", Url, bytes.NewBuffer([]byte(jsonstr)))
	req.Header.Add("X-Token", msg["X-Token"].(string))
	req.Header.Add("x-requested-with", "JSONHttpRequest")
	response, err := client.Do(req)
	if err != nil {
		err = fmt.Errorf("HTTP GET Code=%v, URI=%v, err=%v", response.StatusCode, Url, err)
		return nil, err
	}
	defer response.Body.Close()
	return ioutil.ReadAll(response.Body)
}

// 获取游戏Url
func requestGetPlay(client *http.Client, url string) (body []byte, err error) {
	req, err := http.NewRequest("GET", url, nil)
	response, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if response.StatusCode != http.StatusOK || err != nil {
		err = fmt.Errorf("HTTP GET Code=%v, URI=%v, err=%v", response.StatusCode, url, err)
		return
	}
	defer response.Body.Close()
	return ioutil.ReadAll(response.Body)
}

// 获取key  获取余额
func HttpGETGlobal(client *http.Client, url string, msg map[string]interface{}) (body []byte, err error) {

	req, err := http.NewRequest("GET", url, nil)
	req.Header.Add("X-Token", msg["X-Token"].(string))
	response, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if response.StatusCode != http.StatusOK || err != nil {
		err = fmt.Errorf("HTTP GET Code=%v, URI=%v, err=%v", response.StatusCode, url, err)
		return
	}
	defer response.Body.Close()
	return ioutil.ReadAll(response.Body)
}
