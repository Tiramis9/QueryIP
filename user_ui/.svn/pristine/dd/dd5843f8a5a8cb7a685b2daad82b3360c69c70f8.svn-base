package crontab

import (
	"errors"
	"fmt"
	"game2/lib/game"
	_ "game2/lib/game/Imone"
	_ "game2/lib/game/allbet"
	_ "game2/lib/game/dg"
	"game2/lib/game/og"
	_ "game2/lib/game/sb"
	_ "game2/lib/game/vr"
	"game2/model"
	"regexp"
	"strconv"
	"time"
)

type UserAccount2 struct {
	GameName    string  `json:"game_name,omitempty"`
	AccountName string  `json:"account_name,omitempty"`
	UserId      int     `json:"user_id,omitempty"`
	Money       float64 `json:"money,omitempty"`
}

const (
	OG    = "OG"
	DG    = "DG"
	IMONE = "IMONE"
)

//游戏类别
var gameMap = map[string]string{

	"OG":    "og",
	"DG":    "dg",
	"IMONE": "imone",
}

func GameRecord(gameCode string, info map[string]interface{}) (interface{}, error) {
	var str string
	//游戏代码,判断
	gameStr, ok := gameMap[gameCode]
	if !ok {
		return str, errors.New("game code error")
	}
	gameClass, err := game.NewGame(gameStr)
	if err != nil {
		return str, err
	}
	// 请求查询
	record, err := gameClass.QueryRecord(info)
	if err != nil {
		return str, err
	}
	// 每个游戏单独处理请求数据
	switch gameCode {
	case OG:
		timenow := time.Now().Unix()
		list := make([]model.GameRecordOg, 0)
		recordlist, ok := record.([]og.ResPutRecord)
		if !ok {
			return nil, errors.New("not recordlist ")
		}
		for i := range recordlist {
			bet, err := strconv.ParseFloat(recordlist[i].Bet, 64)
			if err != nil {
				return nil, err
			}
			lose, err := strconv.ParseFloat(recordlist[i].Bet, 64)
			if err != nil {
				return nil, err
			}
			betdate, err := MatchDate(recordlist[i].BettingDate)
			if err != nil {
				return nil, err
			}
			temp := model.GameRecordOg{
				GameProvider:   recordlist[i].GameProvider,
				MemberName:     recordlist[i].MemberName,
				GameName:       recordlist[i].GameName,
				BettingCode:    recordlist[i].BettingCode,
				BettingDate:    betdate,
				GameId:         recordlist[i].GameId,
				RoundNo:        recordlist[i].Roundno,
				Result:         recordlist[i].Result,
				Bet:            bet,
				Win_loseResult: lose,
				BettingAmount:  recordlist[i].BettinGamount,
				ValidBet:       recordlist[i].ValidBet,
				WinLoseAmount:  recordlist[i].Winloseamount,
				Balance:        recordlist[i].Balance,
				Currency:       recordlist[i].Currency,
				Handicap:       recordlist[i].Handicap,
				Status:         recordlist[i].Status,
				GameCategory:   recordlist[i].Gamecategory,
				SettleDate:     recordlist[i].Settledate,
				Remark:         recordlist[i].Remark,
				CreateTime:     timenow,
				UpdateTime:     timenow,
			}
			list = append(list, temp)
		}
		err = model.GameRecordOgAddInfo(model.Db, list)
		if err != nil {
			return nil, err
		}
		return nil, nil
	case DG:
	}
	return nil, nil
}

// 匹配时间 返回时间戳 1541030400
func MatchDate(Msg string) (string, error) {
	var str string
	myexp := regexp.MustCompile(`[0-9]+`)
	result := myexp.FindAllStringSubmatch(Msg, 1)
	if result == nil {
		return "", errors.New("Please enter valid IP information!")
	}
	for _, value := range result {
		if value != nil {
			for _, str = range value {
			}
		}
	}
	timeInt, err := strconv.ParseInt(str, 10, 64)
	if err != nil {
		return "", err
	}
	timeInt /= 1000
	timeSter := strconv.FormatInt(timeInt, 10)
	//	timeSter := time.Unix(timeInt, 0)
	//	timeSter.Format("2006-01-02 03:04:05 PM")
	return timeSter, nil
}

func getTimeStr(mtime string) string {
	var date string
	myexp := regexp.MustCompile(`(\d{4})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})`)
	result := myexp.FindAllString(mtime, 1)
	for _, date = range result {
	}
	return date
}

//New time，返回 格式2018-11-12 08:22:54,间隔10分钟
func NewOGTimeDate() (startTime string, endTime string) {
	const base_format = "2006-01-02 15:04:05"
	timeInt := time.Now().Unix()
	timeSter := time.Unix(timeInt, 0)
	start, _ := time.ParseDuration("-10m")
	sDate := timeSter.Add(start)
	nowTime := getTimeStr(timeSter.String())
	begin := getTimeStr(sDate.String())
	fmt.Printf("start:%v endDate:%v\n", begin, nowTime)
	return begin, begin
}
