package og

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// OG
type (
	GameOG struct {
		//game.Server
		// Token  string `json:"token"`
		Status     string                 `json:"status"`
		Data       map[string]interface{} `json:"data"`
		User       string
		Key        string
		ProviderId int
		/*
			Agent  string

			DesKey string
			Md5Key string
		*/
	}
)

const (
	ERR_SYSTEM_ERROR       = "system error"
	ERR_NET_ERROR          = "network error"
	ERR_AUTH_FAILED        = "auth failed"
	ERR_SIGN_ERROR         = "sign error"
	ERR_APPID_ERROR        = "appid error"
	ERR_SECRET_ERROR       = "secret error"
	ERR_LACK_PARAMETERS    = "Lack of necessary parameters"
	ERR_BALANCE_NOT_ENOUGH = "balance is not enough"
	ERR_ILLEGAL_IP         = "illegal ip"
	KC_RAND_KIND_NUM       = 0    // 纯数字
	KC_RAND_KIND_LOWER     = 1    // 小写字母
	KC_RAND_KIND_UPPER     = 2    // 大写字母
	KC_RAND_KIND_ALL       = 3    // 数字、大小写字母
	DEFAULT_PAGE           = "1"  //默认第几页
	DEFAULT_PAGECOUNT      = "10" //默认一页多少数量
	LOGIN_EXPIRED_TIME     = 3600 //token过期时间
	//redis key值
	INFO_USER  = "info_user"
	INFO_MERCH = "info_merch"
	GAME_AG    = "1"
	GAME_BBIN  = "2"
	GAME_SB    = "3"
	GAME_AB    = "4"
)

//Post 请求方法,返回请求的消息
func HttpPost(go_url string, params map[string]string) string {
	query := url.Values{}
	for key, value := range params {
		query.Add(key, value)
	}
	fmt.Println(query)
	resp, err := http.PostForm(go_url, query)
	if err != nil {
		fmt.Println(err)
		return ERR_NET_ERROR
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Println(err)
		return ERR_NET_ERROR
	}

	return string(body)
}

//Post 请求方法,返回请求的消息
func HandleDeal(go_url string, params map[string]string) string {
	query := url.Values{}
	for key, value := range params {
		query.Add(key, value)
	}
	fmt.Println(query)

	resp, err := http.PostForm(go_url, query)
	if err != nil {
		fmt.Println(err)
		return ERR_NET_ERROR
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Println(err)
		return ERR_NET_ERROR
	}

	return string(body)
}

// 代理本地服务器
func NewHttpClient(proxyAddr string) (*http.Client, error) {
	proxy, err := url.Parse(proxyAddr)
	if err != nil {
		return nil, err
	}
	netTransport := &http.Transport{
		//Proxy: http.ProxyFromEnvironment,
		Proxy: http.ProxyURL(proxy),
		Dial: func(netw, addr string) (net.Conn, error) {
			c, err := net.DialTimeout(netw, addr, time.Second*time.Duration(10))
			if err != nil {
				return nil, err
			}
			return c, nil
		},
		MaxIdleConnsPerHost:   15,                             //每个host最大空闲连接
		ResponseHeaderTimeout: time.Second * time.Duration(8), //数据收发5秒超时
	}

	return &http.Client{
		Timeout:   time.Second * 20,
		Transport: netTransport,
	}, nil
}

// 获取Token
func HttpGET(client *http.Client, url string) (body []byte, err error) {
	resp, err := http.NewRequest("GET", url, nil)
	resp.Header.Add("X-Operator", ALLBET_OPERATOR_NAME)
	resp.Header.Add("X-Key", TEST_OPERATOR_KEY)
	response, err := client.Do(resp)
	if err != nil {
		return nil, err
	}
	if response.StatusCode != http.StatusOK || err != nil {
		err = fmt.Errorf("HTTP GET Code=%v, URI=%v, err=%v", response.StatusCode, url, err)
		return
	}
	defer response.Body.Close()
	return ioutil.ReadAll(response.Body)
}

// 注册
func HttpPOST(client *http.Client, Url string, msg map[string]interface{}) (body []byte, err error) {

	postValue := url.Values{}
	for key, value := range msg {
		if key != "X-Token" {
			switch v := value.(type) {
			case string:
				postValue.Add(key, v)
			case float64:
				fmt.Println("blance:", key, v)
				//postValue.Add(key, string(v))
				//blance = v
			}
		}
	}
	//postString := postValue.Encode()
	resp, err := http.NewRequest("POST", Url, strings.NewReader(postValue.Encode()))
	for key, value := range msg {
		if key == "X-Token" {
			switch v := value.(type) {
			case string:
				resp.Header.Add(key, v)
			}
		}
	}
	resp.Header.Add("Content-Type", "application/x-www-form-urlencoded")
	resp.Header.Add("x-requested-with", "JSONHttpRequest")
	response, err := client.Do(resp)
	if err != nil {
		err = fmt.Errorf("HTTP GET Code=%v, URI=%v, err=%v", response.StatusCode, Url, err)
		return nil, err
	}
	defer response.Body.Close()
	return ioutil.ReadAll(response.Body)
}

// 注册test
func HttpPOSTtest(client *http.Client, Url string, msg map[string]interface{}) (body []byte, err error) {
	data := make(map[string]interface{})
	// postValue := url.Values{}  // 提取请求信息 byte发送
	for key, value := range msg {
		if key != "X-Token" {
			switch v := value.(type) {
			case string:
				//postValue.Add(key, v)
				data[key] = v
			case float64:
				data[key] = v
			}
		}
	}
	jsonstr, err := json.Marshal(data)
	if err != nil {
		return nil, err
	}
	fmt.Println("req:", string(jsonstr))
	//body := bytes.NewBuffer([]byte(jsonstr))
	//body := &bytes.Buffer{}
	// resp, err := http.NewRequest("POST", Url, strings.NewReader(postValue.Encode()))
	resp, err := http.NewRequest("POST", Url, bytes.NewBuffer([]byte(jsonstr)))
	for key, value := range msg {
		if key == "X-Token" {
			switch v := value.(type) {
			case string:
				resp.Header.Add(key, v)
			}
		}
	}
	resp.Header.Add("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
	resp.Header.Add("Accept-Language", "ja,zh-CN;q=0.8,zh;q=0.6")
	resp.Header.Add("Connection", "keep-alive")
	resp.Header.Add("Cookie", "设置cookie")
	resp.Header.Add("User-Agent", "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:12.0) Gecko/20100101 Firefox/12.0")
	//resp.Body()
	resp.Header.Add("Content-Type", "application/form-data")
	resp.Header.Add("x-requested-with", "JSONHttpRequest")
	resp.Header.Add("Content-Type", "application/json; charset=utf-8;charset=us-ascii")
	response, err := client.Do(resp)
	if err != nil {
		err = fmt.Errorf("HTTP GET Code=%v, URI=%v, err=%v", response.StatusCode, Url, err)
		return nil, err
	}
	defer response.Body.Close()
	return ioutil.ReadAll(response.Body)
}

// 获取余额
func HttpGETBalance(client *http.Client, url string, msg map[string]interface{}) (body []byte, err error) {
	req, err := http.NewRequest("GET", fmt.Sprintf("%v?username=%v", url, msg["username"].(string)), nil)
	req.Header.Add("X-Token", msg["X-Token"].(string))

	response, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if response.StatusCode != http.StatusOK || err != nil {
		err = fmt.Errorf("HTTP GET Code=%v, URI=%v, err=%v", response.StatusCode, url, err)
		return
	}
	defer response.Body.Close()
	return ioutil.ReadAll(response.Body)
}
