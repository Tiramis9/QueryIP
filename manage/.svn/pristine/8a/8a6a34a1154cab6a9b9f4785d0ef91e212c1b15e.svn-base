package model

import "github.com/jinzhu/gorm"

type UserBackAddBill struct {
	Id         int
	UserId     int
	Type       int
	SettAmt    float64
	Memo       string
	Tips       string
	Fee        float64
	Balance    float64
	OldBalance float64
	Status     int
	OrderSn    string
	Code       int
	CreateTime int64
	MerchantId int
	Operator   int
}

type MemberBillInfo struct {
	UserBackAddBill
	TrueName string
	UserName string
}

func GetMemberBill(db *gorm.DB, userId, page, pageCount int, m map[string]interface{}) ([]MemberBillInfo, int, error) {
	whereStr := "u.id=?"
	condition := []interface{}{userId}
	if v, ok := m["user_type"]; ok {
		whereStr += " AND u.type=?"
		condition = append(condition, v)
	}
	if v, ok := m["type"]; ok {
		whereStr += " AND ubb.type=?"
		condition = append(condition, v)
	}
	if v, ok := m["code"]; ok {
		whereStr += " AND ubb.code=?"
		condition = append(condition, v)
	}
	if v1, ok1 := m["start_time"]; ok1 {
		if v2, ok2 := m["end_time"]; ok2 {
			whereStr += " AND ?<=ubb.create_time AND ubb.create<=?"
			condition = append(condition, v1, v2)
		} else {
			whereStr += " AND ?<=ubb.create_time"
			condition = append(condition, v1)
		}
	} else {
		if v2, ok2 := m["end_time"]; ok2 {
			whereStr += " AND ubb.create<=?"
			condition = append(condition, v2)
		}
	}
	if v, ok := m["user_name"]; ok {
		whereStr += " AND u.user_name LIKE ?"
		userName, _ := v.(string)
		condition = append(condition, "%"+userName+"%")
	}

	list := make([]MemberBillInfo, 0)
	if err := db.Table(`user_backadd_bill AS ubb`).Joins(`
		LEFT JOIN user AS u ON u.id=ubb.user_id
	`).Select(`
		ubb.*,
		u.true_name,
		u.user_name
	`).Where(whereStr, condition...).Offset((page - 1) * pageCount).Limit(pageCount).Find(&list).Order(`
		ubb.create_time DESC
	`).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, 0, nil
		}
		return nil, 0, err
	}

	var count int
	if err := db.Table(`user_backadd_bill AS ubb`).Joins(`
		LEFT JOIN user AS u ON u.id=ubb.user_id
	`).Select(`
		ubb.*,
		u.true_name,
		u.user_name
	`).Where(whereStr, condition...).Count(&count).Error; err != nil {
		return nil, 0, err
	}

	return list, count, nil
}
